user nobody;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    # include mime types
    include conf.d/mime.types;
    default_type application/octet-stream;

    # DNS resolver for dynamic upstream resolution
    resolver 127.0.0.11 valid=30s;  # Docker's internal DNS
    resolver_timeout 3s;

    lua_shared_dict auth_failures 10m;

    lua_package_path "/etc/nginx/lua/?.lua;/usr/share/lua/common/?.lua;/usr/share/lua/common/?/init.lua;;";
    # log format for access logs
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    '"$http_x_api_client_id" "$http_x_consortium_member_id" '
                    '$request_time $upstream_response_time';

    access_log /var/log/nginx/access.log main;

    # nginx performance settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 10M;

    # Rate limiting zones
    limit_req_zone $http_x_forwarded_for zone=api_limit:1m rate=100r/s;
    limit_req_zone $http_x_forwarded_for zone=query_limit:1m rate=50r/s;
    limit_req_zone $http_x_forwarded_for zone=audit_limit:1m rate=20r/s;

    # Upstream for Log Ingestion Service (HTTP)
    upstream ingestion_http {
        least_conn;
        #server ingestion-service:8091 max_fails=3 fail_timeout=30s;
        server 127.0.0.1:8091 max_fails=3 fail_timeout=30s;
        # Add more instances for load balancing:
        # server ingestion-service-2:8091 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # Upstream for Log Ingestion Service (gRPC)
    upstream ingestion_grpc {
        least_conn;
        #server ingestion-service:50051 max_fails=3 fail_timeout=30s;
        server 127.0.0.1:50051 max_fails=3 fail_timeout=30s;
        # Add more instances for load balancing:
        # server ingestion-service-2:50051 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # Upstream for Query Service
    upstream query_service {
        least_conn;
        #server query-service:8082 max_fails=3 fail_timeout=30s;
        server 127.0.0.1:8082 max_fails=3 fail_timeout=30s;
        # Add more instances for load balancing:
        # server query-service-2:8082 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # HTTP/HTTPS transformation server block
    server {
        listen 80;
        listen [::]:80;
        server_name api-gateway;

        # Health check endpoint (no authentication required)
        location /health {
            access_log off;
            return 200 "healthy";
            add_header Content-Type text/plain;
        }

        location / {
            return 301 https://$host$request_uri;
        }
    }

    # todo config dry
    # HTTPS Server Block - Main API Gateway
    server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;
        server_name api-gateway;

        # TLS Configuration
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

        # mTLS Configuration for Consortium Member Authentication
        # Note: ssl_client_certificate must be in server block, not location block
        # Using 'optional' allows non-mTLS routes to work, but Lua script enforces mTLS for specific routes
        ssl_client_certificate /etc/nginx/ssl/ca-cert.pem;
        ssl_verify_client optional;  # Optional: allows requests without cert, but Lua enforces for mTLS routes
        ssl_verify_depth 2;

        # Security Headers (HSTS and other security headers)
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # ============================================
        # Log Submission Routes (API Key Authentication)
        # ============================================

        # HTTP POST /v1/logs - Log Submission (API Key Authentication)
        location /v1/logs {
            # Rate limiting
            limit_req zone=api_limit burst=20 nodelay;
            
            # Only allow POST method
            limit_except POST {
                deny all;
            }

            error_page 403 =405 /405;
            
            # API Key Authentication
            access_by_lua_file /etc/nginx/lua/api-key-auth.lua;
            
            # Proxy to Log Ingestion Service
            proxy_pass http://ingestion_http;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Pass authentication context to backend
            proxy_set_header X-API-Client-ID $http_x_api_client_id;
            proxy_set_header X-Client-Org-ID $http_x_client_org_id;
            proxy_set_header X-Source-IP $remote_addr;
            
            # Timeouts
            proxy_connect_timeout 10s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
            
            # Buffering
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
            
            # Error handling
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
        }

        # ============================================
        # Query Routes (API Key Authentication)
        # ============================================

        # GET /v1/query/status/{request_id} - Task Status Query (API Key Authentication)
        # For API callers to query attestation status using returned request_id
        location ~ ^/v1/query/status/(.+)$ {
            # Rate limiting
            limit_req zone=query_limit burst=10 nodelay;
            
            # Only allow GET method
            limit_except GET {
                deny all;
            }

            error_page 403 =405 /405;
            
            # API Key Authentication
            access_by_lua_file /etc/nginx/lua/api-key-auth.lua;
            
            # Proxy to Query Service
            proxy_pass http://query_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Pass authentication context
            proxy_set_header X-API-Client-ID $http_x_api_client_id;
            proxy_set_header X-Client-Org-ID $http_x_client_org_id;
            proxy_set_header X-Source-IP $remote_addr;
            
            # Timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
            
            # Error handling
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
        }

        # POST /v1/query_by_content - Content-based Reverse Query (API Key Authentication)
        # For non-API users (Syslog, Kafka) to reverse lookup on-chain credentials using log content
        location /v1/query_by_content {
            # Rate limiting
            limit_req zone=query_limit burst=10 nodelay;
            
            # Only allow POST method
            limit_except POST {
                deny all;
            }

            error_page 403 =405 /405;
            
            # API Key Authentication
            access_by_lua_file /etc/nginx/lua/api-key-auth.lua;
            
            # Proxy to Query Service
            proxy_pass http://query_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
            
            # Pass authentication context
            proxy_set_header X-API-Client-ID $http_x_api_client_id;
            proxy_set_header X-Client-Org-ID $http_x_client_org_id;
            proxy_set_header X-Source-IP $remote_addr;
            
            # Timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
            
            # Error handling
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
        }

        # ============================================
        # On-Chain Audit Routes (mTLS + IP Whitelist)
        # ============================================
        
        # GET /v1/audit/log/{log_hash} - Audit by Log Hash (mTLS + IP Whitelist)
        # For consortium members to audit on-chain log data by content hash
        location ~ ^/v1/audit/log/(.+)$ {
            # Rate limiting
            limit_req zone=audit_limit burst=5 nodelay;
            
            # Only allow GET method
            limit_except GET {
                deny all;
            }

            error_page 403 =405 /405;
            
            # mTLS + IP Whitelist Authentication (dual authentication)
            access_by_lua_file /etc/nginx/lua/mtls-ip-auth.lua;
            
            # Proxy to Query Service
            proxy_pass http://query_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Pass authentication context
            proxy_set_header X-Cert-Subject $ssl_client_s_dn;
            proxy_set_header X-Member-ID $http_x_member_id;
            proxy_set_header X-Source-IP $remote_addr;
            
            # Timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 15s;
            proxy_read_timeout 15s;
            
            # Error handling
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
        }

        # GET /log/by_tx/{tx_hash} - Query by Transaction Hash (mTLS + IP Whitelist)
        # For consortium members to audit on-chain log data
        location ~ ^/log/by_tx/(.+)$ {
            # Rate limiting
            limit_req zone=audit_limit burst=5 nodelay;
            
            # Only allow GET method
            limit_except GET {
                deny all;
            }

            error_page 403 =405 /405;
            
            # mTLS + IP Whitelist Authentication (dual authentication)
            access_by_lua_file /etc/nginx/lua/mtls-ip-auth.lua;
            
            # Proxy to Query Service
            proxy_pass http://query_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Pass authentication context
            proxy_set_header X-Consortium-Member-ID $http_x_consortium_member_id;
            proxy_set_header X-Client-Cert-DN $ssl_client_s_dn;
            proxy_set_header X-Client-Cert-Serial $ssl_client_serial;
            proxy_set_header X-Source-IP $remote_addr;
            
            # Timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
            
            # Error handling
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
        }

        # GET /log/{on_chain_log_id} - Query by On-Chain Log ID (mTLS + IP Whitelist)
        # For consortium members to audit on-chain log data
        location ~ ^/log/([^/]+)$ {
            # Rate limiting
            limit_req zone=audit_limit burst=5 nodelay;
            
            # Only allow GET method
            limit_except GET {
                deny all;
            }

            error_page 403 =405 /405;
            
            # mTLS + IP Whitelist Authentication (dual authentication as per design doc)
            access_by_lua_file /etc/nginx/lua/mtls-ip-auth.lua;
            # Proxy to Query Service
            proxy_pass http://query_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Pass authentication context
            proxy_set_header X-Consortium-Member-ID $http_x_consortium_member_id;
            proxy_set_header X-Client-Cert-DN $ssl_client_s_dn;
            proxy_set_header X-Client-Cert-Serial $ssl_client_serial;
            proxy_set_header X-Source-IP $remote_addr;
            
            # Timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
            
            # Error handling
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
        }

        location = /405 {
            internal;
            return 405 "Method Not Allowed\n";
        }

        # Default deny
        location / {
            return 404 "Not Found\n";
        }
    }

    # gRPC Server Block
    server {
        listen 50052 ssl http2;
        listen [::]:50052 ssl http2;
        server_name api-gateway;

        # TLS Configuration
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

        # mTLS Configuration for Consortium Member Authentication
        # Note: ssl_client_certificate must be in server block, not location block
        # Using 'optional' allows non-mTLS routes to work, but Lua script enforces mTLS for specific routes
        ssl_client_certificate /etc/nginx/ssl/ca-cert.pem;
        ssl_verify_client optional;  # Optional: allows requests without cert, but Lua enforces for mTLS routes
        ssl_verify_depth 2;

        # gRPC requires HTTP/2
        http2_max_field_size 16k;
        http2_max_header_size 32k;

        # gRPC SubmitLog endpoint (API Key Authentication)
        # Routes gRPC SubmitLog requests to Log Ingestion Service
        location /logingestion.LogIngestion/SubmitLog {
            # API Key Authentication via gRPC metadata
            access_by_lua_file /etc/nginx/lua/grpc-api-key-auth.lua;
            
            # Proxy to Ingestion Service gRPC
            grpc_pass grpc://ingestion_grpc;
            grpc_set_header Host $host;
            grpc_set_header X-Real-IP $remote_addr;
            grpc_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            grpc_set_header X-Forwarded-Proto $scheme;
            
            # Pass authentication context via gRPC metadata (as per design doc)
            grpc_set_header X-API-Client-ID $http_x_api_client_id;
            grpc_set_header X-Client-Org-ID $http_x_client_org_id;
            grpc_set_header X-Source-IP $remote_addr;
            
            # Timeouts
            grpc_connect_timeout 10s;
            grpc_send_timeout 30s;
            grpc_read_timeout 30s;
            
            # Error handling
            grpc_next_upstream error timeout invalid_header http_500 http_502 http_503;
        }

        # Health check for gRPC
        location / {
            grpc_pass grpc://ingestion_grpc;
        }
    }
}

