input:
  broker:
    inputs:
      - socket_server:
          network: udp
          address: ${SYSLOG_UDP_ADDR:0.0.0.0:5514}
      - socket_server:
          network: tcp
          address: ${SYSLOG_TCP_ADDR:0.0.0.0:6514}

# applies back pressure to a processing pipeline when the limit is reached rather than abandon
rate_limit_resources:
  - label: log_ingest_limit
    local:
      count: ${RATE_LIMIT_COUNT:500}
      interval: ${RATE_LIMIT_PERIOD:1s}

pipeline:
  processors:
    - label: optional_rate_limit
      switch:
        - check: env("RATE_LIMIT_ENABLED").or("false") == "true"
          processors:
            - rate_limit:
                resource: log_ingest_limit

    - label: parse_syslog
      parse_log:
        format: syslog_rfc5424
        best_effort: true

    # Verify the parsing result, discard if all fields are empty
    - label: validate_syslog
      mapping: |
        root = if this.message.not_empty() && this.timestamp.not_empty() {
          this
        } else {
          deleted()
        }

    - label: normalize_syslog
      mapping: |
        root.log_content = this.message
        root.client_source_org_id = env("DEFAULT_ORG_ID").or("")
        root.client_timestamp = this.timestamp

output:
  http_client:
    url: ${INGESTION_ENDPOINT:http://ingestion:8091/v1/logs}
    verb: POST
    headers:
      Content-Type: application/json
      X-Source-Adapter: syslog
    timeout: 5s
    retries: 10
    retry_period: 2s
    max_retry_backoff: 1m
    batching:
      count: ${HTTP_BATCH_COUNT:200}
      byte_size: ${HTTP_BATCH_BYTES:200000}
      period: ${HTTP_BATCH_PERIOD:1s}